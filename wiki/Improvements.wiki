Several things have been improved from IB API to ease development and to improve efficiency.

=Ease development=
==To type or not to type?==
===IB API===
Almost no enum exists. Input and output parameters are native type (int, long...). Not so readable and not too easy to maintain code.

===Neo IB API===
Every native input and output parameters have been typed. So now when you're placing a buy order, no more {{{"BUY"}}} String coding. Use {{{OrderAction.BUY}}} enum.

==Handle tick price events==
===IB API===
When requesting market data, EReader firstly read tick price event then call tickPrice() callback method, secondly call tickSize() callback method. Not so easy to bind price and size if you've implemented multi-threading on your own.

===Neo IB API===
Just subscribe to {{{MarketDataSubscriptionRequest}}} then listen to {{{CompositeTickEventListener}}} to be notified of a {{{TickPriceEvent}}} binded to a {{{TickSizeEvent}}}.

==Manage reqId, tickerId, orderId or whatEverId==
===IB API===
When requesting market data, one has to provide an {{{int}}} for the request (not really human readable) and maintains it until the call of the callback method.
When placing an order, one has to provide an {{{int}}} for the order id (not really human readable) and again maintains it until the call of orderStatus() callback method.

===Neo IB API===
All ids are human readable as they are {{{String}}} typed. When subscribing or sending a request, one can provide a {{{String}}} id or let the API generates automatically a human readable id using object's fields concatenation.

=Efficiency=
==Implementation of multi-threading==
===IB API===
One thread to send requests and place orders (must be synchronized). Only one thread to read from {{{InputStream}}} and dispatch to EWrapper callback methods.

===Neo IB API===
One thread to send requests and place orders (must be synchronized). One consumer thread reading from {{{InputStream}}}. One thread pool publishing events. One thread pool notifying events to listeners.

=={{{StrBuilder}}} has replaced {{{StringBuffer}}}==
===IB API===
In EReader object, method readStr() uses a {{{StringBuffer}}} and instantiates a new one every time. One has to know this method is called thousand times a minute.
{{{
protected String readStr() throws IOException {
  StringBuffer buf = new StringBuffer();
  while (true) {
    byte c = m_dis.readByte();
    if (c == 0) {
      break;
    }
    buf.append((char) c);
  }

  String str = buf.toString();
  return str.length() == 0 ? null : str;
}
}}}

===Neo IB API===
{{{StringBuffer}}} has been replaced with {{{StrBuilder}}} (I chose {{{StrBuilder}}} from commons-lang as there are shortcut methods) as there is only one consumer, no need to synchronized. Only one instance exists of {{{StrBuilder}}} (singleton), no new instantiation each read.
{{{
public static final String readString(final InputStream inputStream) {
  BUILDER.clear();
  while (true) {
    final byte c = readByte(inputStream);
    if (c == 0) {
      break;
    }
    BUILDER.append((char) c);
  }
  final String s = BUILDER.toString();
  return s.length() == 0 ? null : s;
}
}}}