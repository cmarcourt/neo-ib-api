Several things have been improved from IB API to ease development and to improve efficiency.

=Ease development=
==To type or not to type?==
===IB API===
Almost no enum exists. Input and output parameters are native type (int, long...). Not so readable and not too easy to maintain code.

===Neo IB API===
Every native input and output parameters have been typed. So now when you're placing a buy order, no more {{{"BUY"}}} String coding. Use {{{OrderAction.BUY}}} enum.

==Handle tick price events==
===IB API===
When requesting market data, EReader firstly read tick price event then call tickPrice() callback method, secondly call tickSize() callback method. Not so easy to bind price and size if you've implemented multi-threading on your own.

===Neo IB API===
Just subscribe to {{{MarketDataSubscriptionRequest}}} then listen to {{{CompositeTickEventListener}}} to be notified of a {{{TickPriceEvent}}} binded to a {{{TickSizeEvent}}}.

=Efficiency=
==Implementation of multi-threading==
===IB API===
One thread to send requests and place orders (must be synchronized). Only one thread to read from {{{InputStream}}} and dispatch to EWrapper callback methods.

===Neo IB API===
One thread to send requests and place orders (must be synchronized). One consumer thread reading from {{{InputStream}}}. One thread pool publishing events. One thread pool notifying events to listeners.

=={{{StrBuilder}}} has replaced {{{StringBuffer}}}==
===IB API===
In EReader object, method readStr() uses a {{{StringBuffer}}} and instantiate a new one every time. One has to know this method is called thousand times a minute.
{{{
protected String readStr() throws IOException {
  StringBuffer buf = new StringBuffer();
  while (true) {
    byte c = m_dis.readByte();
    if (c == 0) {
      break;
    }
    buf.append((char) c);
  }

  String str = buf.toString();
  return str.length() == 0 ? null : str;
}
}}}

===Neo IB API===
{{{StringBuffer}}} has been replaced with {{{StrBuilder}}} (I chose {{{StrBuilder}}} from commons-lang as there are shortcut methods) as there is only one consumer, no need to synchronized. Only one instance exists of {{{StrBuilder}}} (singleton), no new instantiation each read.
{{{
public static final String readString(final InputStream inputStream) {
  BUILDER.clear();
  while (true) {
    final byte c = readByte(inputStream);
    if (c == 0) {
      break;
    }
    BUILDER.append((char) c);
  }
  final String s = BUILDER.toString();
  return s.length() == 0 ? null : s;
}
}}}