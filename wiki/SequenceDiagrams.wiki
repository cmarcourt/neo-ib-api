= IB API =
Here is how today existing IB API works (approximatively):
http://aonyx.ch/neo-ib-api/uml/ib-api/current_sequence.gif

One can see that problems can occur during callback methods (red colored): tickPrice(), tickSize()... as it is the same thread (EReader) reading from {{{InputStream}}} and executing code within these callback methods.

You must avoid long operations or performances will decrease *dramatically*. Funny thing is you may listen to tick price events to trigger process which then place orders or store data in a database for example.

To avoid these blocking (long) operations, one has to implement multi-threading design in its code so that EReader thread is released faster and it can process a new event.

=Neo IB API=
==Request==
http://aonyx.ch/neo-ib-api/uml/neo-ib-api/request_sequence.gif

Not much to say on the request side. All requests must be synchronized so one thread is used like IB API.

Although requests are called on the {{{Session}}} object and not directly on the client object.

==Event==
http://aonyx.ch/neo-ib-api/uml/neo-ib-api/consumer_sequence.gif

A completely different design.

The {{{EventInputStreamConsumerThread}}} read from the {{{InputStream}}}. As soon as the stream is consumed an event is created and published to [http://code.google.com/p/disruptor/ Disruptor]. {{{Disruptor}}} uses its own thead to handle event.

Each events to publish are delegated to {{{EventPublisher}}} thread pooled (Thread Pool1). {{{EventNotifier}}} notifies each events to listeners within a separate thread (Thread Pool2).

Now long operations are welcomed !