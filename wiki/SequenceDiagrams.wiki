= IB API =
Here is how today existing IB API works (approximatively):
http://aonyx.ch/neo-ib-api/uml/ib-api/current_sequence.gif

One can see that problems can occur during callback methods (red colored): tickPrice(), tickSize()... as it is the same thread (EReader) reading from InputStream and executing code within these callback methods.

You must avoid long operations or performances will decrease *dramatically*. Funny thing is you may listen to tick price events to trigger process which then place orders or store data in a database for example.

To avoid these blocking (long) operations, one has to implement multi-threading design in its code so that EReader thread is released faster and it can process a new event.

=Neo IB API=
==Request==
http://aonyx.ch/neo-ib-api/uml/neo-ib-api/request_sequence.gif

Not much to say on the request side. All requests must be synchronized so one thread is used like IB API.

Although requests are called on the Session object and not directly on the client object.

==Event==
http://aonyx.ch/neo-ib-api/uml/neo-ib-api/consumer_sequence.gif

A completely different design.

The EventInputStreamConsumerThread read from the InputStream. As soon as the stream is consumed an event is created and published to [http://code.google.com/p/disruptor/ disruptor].